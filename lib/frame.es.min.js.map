{"version":3,"file":"frame.es.min.js","sources":["../src/mount.js","../src/route.js","../src/element.js","../src/request.js","../src/range.js","../src/PromiseSwitcher.js","../src/index.js"],"sourcesContent":["function select(arg) {\n    if(arg instanceof Element)\n        return arg;\n    else\n        return document.querySelector(arg);\n}\n\n/* Traverse a node tree and converts everything to html elements\n * @param {HTMLElement,Array,Promise,function,string,Component} node Tree of elements\n * @param {function} callback Call on each resolved element for the caller to make desired operations on element\n * @returns undefined if all elements processed synchronously, instanceof Promise resolved when all elements are ready if async\n */\nfunction traverse(node, callback) {\n    // use directly html element\n    if(node instanceof Node) {\n        callback(node, null);\n    }\n    // list of elements\n    else if(Array.isArray(node)) {\n        let promises;\n        for(let i = 0; i < node.length; i++) {\n            const currentNode = node[i];\n            // at least one promise in the list, traversal will be async\n            if(currentNode instanceof Promise) {\n                if(!promises)\n                    promises = [currentNode];\n                else\n                    promises.push(currentNode);\n                \n                currentNode.then(result => {\n                    traverse(result, (element, before) => {\n                        node[i] = element;\n                        // find were our element should be located\n                        for(let j = i + 1; j < node.length; j++) {\n                            if(node[j] && node[j] instanceof Node) {\n                                before = node[j];\n                                break;\n                            }\n                        }\n                        callback(element, before);\n                    });\n                });\n            }\n            // synchronous case\n            else {\n                traverse(currentNode, callback);\n            }\n        }\n        // wait for promises to complete\n        if(promises) {\n            return Promise.all(promises);\n        }\n    }\n    // promise : resolve\n    else if(node instanceof Promise) {\n        return node.then(node => traverse(node, callback));\n    }\n    // nothing : skip\n    else if(node === null || node === undefined) {\n    }\n    else {\n        const type = typeof(node);\n\n        // component\n        if(type === 'object' && node.__proto__.constructor.name !== 'Object' && 'el' in node && node.el instanceof Node) {\n            callback(node.el, null);\n        }\n        // dynamic function\n        else if(type === 'function') {\n            return traverse(node(), callback);\n        }\n        // consider everything else as text\n        else {\n            callback(document.createTextNode(node), null);\n        }\n    }\n}\n\n/**\n * Clears all contents of element\n * @param {HTMLElement} element\n */\nmount.clear = function(selector) {\n    const element = select(selector);\n    if(element.childNodes.length > 0)\n        element.innerHTML = ''; // quick clear\n}\n\n/**\n * Mount children elements into parent\n * Replaces all previous content inside parent\n * @param {HTMLElement} parent \n * @param {HTMLElement,Array,Promise,function,string,Component} children\n */\nfunction mount(parentSelector, children) {\n    const parent = select(parentSelector);\n    mount.clear(parent);\n    return mount.append(parent, children);\n}\n\n/**\n * Mount children elements before all existing elements of parent\n * @param {HTMLElement} parent \n * @param {HTMLElement,Array,Promise,function,string,Component} children\n */\nmount.prepend = function(parentSelector, children) {\n    const parent = select(parentSelector);\n    return mount.before(parent, children, parent.firstChild);\n};\n\n/**\n * Mount children elements after all existing elements of parent\n * @param {HTMLElement} parent \n * @param {HTMLElement,Array,Promise,function,string,Component} children\n */\nmount.append = function(parentSelector, children) {\n    const parent = select(parentSelector);\n    return mount.after(parent, children, null);\n};\n\n/**\n * Mount children elements before reference element of parent\n * @param {HTMLElement} parent \n * @param {HTMLElement,Array,Promise,function,string,Component} children\n * @param {HTMLElement} reference \n */\nmount.before = function(parentSelector, children, reference) {\n    const parent = select(parentSelector);\n    return traverse(children, (element, reference2) => {\n        parent.insertBefore(element, reference2 ? reference2 : reference);\n    });\n};\n\n/**\n * Mount children elements after reference element of parent\n * @param {HTMLElement} parent \n * @param {HTMLElement,Array,Promise,function,string,Component} children\n * @param {HTMLElement} reference \n */\nmount.after = function(parentSelector, children, reference) {\n    const parent = select(parentSelector);\n    const after = reference ? reference.nextSibling : null;\n    return traverse(children, (element, after2) => {\n        parent.insertBefore(element, after2 ? after2 : after);\n    });\n};\n\nmount.replace = function(children, reference) {\n    if(children) {\n        return traverse(children, (element) => {\n            reference.parentNode.replaceChild(element, reference)\n        });\n    }\n    else {\n        mount.clear(reference.parentNode);\n    }\n};\n\nfunction unmount(children) {\n    for(const child of Array.isArray(children) ? children : [children])\n        child.remove();\n}\n\nexport {mount, unmount};\n","import {mount} from './mount';\n\n/**\n * Initializes the frame router\n * \n * @param {HTMLElement} root root container element\n * @param {Object} table map of each route. key is pattern, value is content\n * @param {*} base base url at which the page is loaded. '' for website at root\n */\nexport function route(root, table, base) {\n    for(const pattern in table) {\n        route.add(pattern, table[pattern]);\n    }\n    route.root = root;\n    if(typeof(base) === 'string')\n        route.base = base;\n\n    window.addEventListener('popstate', ({state}) => {\n        if(state) {\n            route.set(state.path, state.params);\n        }\n        else {\n            route.set(document.location.pathname + document.location.hash);\n        }\n    });\n    route.set(document.location.pathname + document.location.hash);\n\n    return route;\n}\n\nroute.base = document.location.pathname + '#';\nroute.table = [];\n\n/**\n * Compiles a regex from a route pattern\n * \n * @param {*} pattern route pattern\n * @returns {RegExp} regexp satisfiying the pattern\n */\nfunction routeToRegex(pattern) {\n    const regex = pattern.replace(/\\//g, '\\\\/').replace(/:(\\w+)/g, '(?<$1>[^\\/]+?)');\n    return new RegExp(`^${regex}$`);;\n}\n\n/**\n * Adds a route to the route table\n * \n * @param {string} pattern\n * @param {function,HTMLElement,FrameElement,Object} content Content to display. Can have a controller function in the middle.\n */\nroute.add = function(pattern, content) {\n    route.table.push({\n        pattern,\n        regex: routeToRegex(pattern),\n        content,\n    });\n};\n\n/**\n * Load route without changing the browser URL\n * \n * @param {string} path route path\n */\nroute.set = function(path) {\n    let [matchingRoute, params] = route.get(path);\n    if(matchingRoute) {\n        // give params if matching route is a function\n        let content = matchingRoute instanceof Function ? matchingRoute(params) : matchingRoute;\n        mount(route.root, content);\n    }\n    else {\n        throw new Error('No route found ' + path);\n    }\n};\n\n/**\n * Load route and change browser URL\n * \n * @param {string} path route path\n */\nroute.go = function(path) {\n    route.set(path);\n    history.pushState({\n        path,\n    }, 'Title', route.base + path);\n};\n\n/**\n * Find a route that matches the given path\n * \n * @param  {string} path route path\n * @returns {[content, params]} The route content and params extracted from the path if any\n */\nroute.get = function(path) {\n    // manage default route\n    if(route.base.substr(-1) === '#' && path + '#' === route.base) {\n        path = '/';\n    }\n    // remove base from path\n    if(path.startsWith(route.base)) {\n        path = path.substring(route.base.length);\n    }\n\n    // find route that matches path\n    for(const r of route.table) {\n        const m = r.regex.exec(path);\n        if(m) {\n            return [r.content, m.groups];\n        }\n    }\n}\n","import {mount} from './mount';\r\nimport {route} from './route';\r\n\r\nexport function explodeTagIdCls(tagIdCls) {\r\n    const [, tag, , id, clss] = /^(\\w*)(#([\\w-]+)|)((\\.[\\w-]+)*)$/g.exec(tagIdCls || '');\r\n    const cls = clss.split('.').slice(1);\r\n    return [tag.length > 0 ? tag : 'div', id && id.length > 0 ? id : null, cls];\r\n};\r\n\r\nexport function element(ns, tagIdCls, arg2, arg3) {\r\n    const [tag, id, cls] = explodeTagIdCls(tagIdCls);\r\n    let attrs, content;\r\n\r\n    // arg2: element attributes, arg3: content\r\n    if(typeof(arg2) === 'object' && arg2.__proto__.constructor.name === 'Object') {\r\n        attrs = arg2;\r\n        content = arg3;\r\n    }\r\n    else {\r\n        content = arg2;\r\n    }\r\n\r\n    const el = ns ? document.createElementNS(ns, tag) : document.createElement(tag);\r\n    if(id) {\r\n        el.id = id;\r\n    }\r\n\r\n    if(cls.length > 0) {\r\n        el.className = cls.join(' ');\r\n    }\r\n\r\n    // route links\r\n    if(route.table && tag === 'a' && !('click' in attrs) && ('href' in attrs)) {\r\n        if(route.get(attrs.href)) {\r\n            attrs.click = (e) => {\r\n                route.go(attrs.href);\r\n                e.preventDefault();\r\n            };\r\n        }\r\n    }\r\n\r\n    if(attrs) {\r\n        for(const [key, value] of Object.entries(attrs)) {\r\n            if(typeof(value) === 'function') {\r\n                el.addEventListener(key, value);\r\n                if(key === 'click' && tag === 'a' && !('href' in attrs)) {\r\n                    el.setAttribute('href', 'javascript:;');\r\n                }\r\n            }\r\n            if(value === false || value === null || value === undefined) {\r\n\t    }\r\n            else {\r\n                el.setAttribute(key, value);\r\n            }\r\n        }\r\n    }\r\n    mount(el, content);\r\n\r\n    return el;\r\n};\r\n","const request = {};\n\nfunction json(url, args) {\n    return fetch(url, args).then(response => response.json());\n}\n\njson.get = function(originalUrl, query = {}) {\n    const url = new URL(originalUrl, document.location.href);\n    const sp = new URLSearchParams(originalUrl.search);\n    for(const [key, value] of Object.entries(query)) {\n        if(Array.isArray(value)) {\n            for(const v of value) {\n                sp.append(key, v);\n            }\n        }\n        else if(value === undefined || value === undefined) {\n        }\n        else {\n            sp.append(key, value);\n        }\n    }\n    url.search = sp.toString();\n    return json(url.toString(), {\n        method: 'GET',\n        credentials: 'include',\n    });\n};\n\njson.post = function(url, data) {\n    return json(url, {\n        method: 'POST',\n        body: JSON.stringify(data),\n        headers: {'Content-Type': 'application/json'},\n        credentials: 'include',\n    });\n};\n\njson.put = function(url, data) {\n    return json(url, {\n        method: 'PUT',\n        body: JSON.stringify(data),\n        headers: {'Content-Type': 'application/json'},\n        credentials: 'include',\n    });\n};\n\njson.delete = function(url, data) {\n    return json(url, {\n        method: 'DELETE',\n        body: JSON.stringify(data),\n        headers: {'Content-Type': 'application/json'},\n        credentials: 'include',\n    });\n};\n\nrequest.json = json;\n\nexport {request};\n","export function* irange(start, end = null, step = 1) {\n    if(arguments.length === 2) {\n        step = end || 1;\n        end = start;\n        start = 0;\n    }\n    if(start > end) {\n        step = -step;\n    }\n    if(step > 0) {\n        for(let i = start; i <= end; i += step) {\n            yield i;\n        }\n    }\n    else {\n        for(let i = start; i >= end; i += step) {\n            yield i;\n        }\n    }\n}\n\nexport function range(start, end = null, step = 1) {\n    return new Array(...irange(start, end, step));\n}\n","import {mount} from './mount.js';\n\nexport class PromiseSwitcher {\n    constructor(init, promise) {\n        this.el = init();\n        promise.then(el => mount.replace(el, this.el));\n    }\n}","import {element as element} from './element.js';\r\nimport {mount, unmount} from './mount.js';\r\nimport {request} from './request.js';\r\nimport {irange, range} from './range.js';\r\nimport {route} from './route.js';\r\nimport {PromiseSwitcher} from './PromiseSwitcher.js';\r\n\r\nfunction html(arg1, arg2, arg3) {\r\n    return element(null, arg1, arg2, arg3);\r\n}\r\nfunction f(arg1, arg2, arg3) {\r\n    return element(null, arg1, arg2, arg3);\r\n}\r\n\r\nfunction svg(arg1, arg2, arg3) {\r\n    return element('http://www.w3.org/2000/svg', arg1, arg2, arg3);\r\n}\r\n\r\nexport default f;\r\nexport {\r\n    element,\r\n    f,\r\n    html,\r\n    svg,\r\n    mount,\r\n    unmount,\r\n    request,\r\n    irange,\r\n    range,\r\n    PromiseSwitcher,\r\n    route,\r\n};\r\n"],"names":["select","arg","Element","document","querySelector","traverse","node","callback","Node","Array","isArray","promises","i","length","currentNode","Promise","push","then","result","element","before","j","all","type","__proto__","constructor","name","el","createTextNode","mount","parentSelector","children","parent","clear","append","unmount","child","remove","route","root","table","base","pattern","add","window","addEventListener","state","set","path","params","location","pathname","hash","routeToRegex","regex","replace","RegExp","ns","tagIdCls","arg2","arg3","tag","id","cls","clss","exec","split","slice","explodeTagIdCls","attrs","content","createElementNS","createElement","className","join","get","href","click","e","go","preventDefault","key","value","Object","entries","setAttribute","selector","childNodes","innerHTML","prepend","firstChild","after","reference","reference2","insertBefore","nextSibling","after2","parentNode","replaceChild","matchingRoute","Error","Function","history","pushState","substr","startsWith","substring","r","m","groups","request","json","url","args","fetch","response","irange","start","end","step","arguments","range","originalUrl","query","URL","sp","URLSearchParams","search","v","undefined","toString","method","credentials","post","data","body","JSON","stringify","headers","put","delete","PromiseSwitcher","init","promise","this","html","arg1","f","svg"],"mappings":"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"}